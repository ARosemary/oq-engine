#  -*- coding: utf-8 -*-
#  vim: tabstop=4 shiftwidth=4 softtabstop=4

#  Copyright (c) 2014, GEM Foundation

#  OpenQuake is free software: you can redistribute it and/or modify it
#  under the terms of the GNU Affero General Public License as published
#  by the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.

#  OpenQuake is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

#  You should have received a copy of the GNU Affero General Public License
#  along with OpenQuake.  If not, see <http://www.gnu.org/licenses/>.

import collections
import itertools
import operator

from openquake.hazardlib.imt import from_string
from openquake.hazardlib.calc import filters
from openquake.hazardlib.site import SiteCollection


SourceRuptureSites = collections.namedtuple(
    'SourceRuptureSites',
    'source rupture sites')


def gen_ruptures(sources, site_coll, maximum_distance, monitor):
    """
    Yield (source, rupture, affected_sites) for each rupture
    generated by the given sources.

    :param sources: a sequence of sources
    :param site_coll: a SiteCollection instance
    :param maximum_distance: the maximum distance
    :param monitor: a Monitor object
    """
    filtsources_mon = monitor.copy('filtering sources')
    genruptures_mon = monitor.copy('generating ruptures')
    filtruptures_mon = monitor.copy('filtering ruptures')
    for src in sources:
        with filtsources_mon:
            s_sites = src.filter_sites_by_distance_to_source(
                maximum_distance, site_coll)
            if s_sites is None:
                continue

        with genruptures_mon:
            ruptures = list(src.iter_ruptures())
        if not ruptures:
            continue

        for rupture in ruptures:
            with filtruptures_mon:
                r_sites = filters.filter_sites_by_distance_to_rupture(
                    rupture, maximum_distance, s_sites)
                if r_sites is None:
                    continue
            yield SourceRuptureSites(src, rupture, r_sites)
    filtsources_mon.flush()
    genruptures_mon.flush()
    filtruptures_mon.flush()


def gen_ruptures_for_site(site, sources, maximum_distance, monitor):
    """
    Yield source, <ruptures close to site>

    :param site: a Site object
    :param sources: a sequence of sources
    :param monitor: a Monitor object
    """
    source_rupture_sites = gen_ruptures(
        sources, SiteCollection([site]), maximum_distance, monitor)
    for src, rows in itertools.groupby(
            source_rupture_sites, key=operator.attrgetter('source')):
        yield src, [row.rupture for row in rows]


class RiskInput(object):
    def __init__(self, imt, taxonomy, assets, gmvs, epsilons=None):
        self.imt = imt
        self.taxonomy = taxonomy
        self.assets = assets
        self.gmvs = gmvs
        self.epsilons = epsilons

    def get_hazards(self):
        return [Hazard(self.imt, self.gmvs)]

    def get_data(self):
        return self.gmvs

    def get_epsilons(self):
        return self.epsilons


def calc_gmfs(oqparam, sitecol, rupture=None, seed=None, realizations=None):
    max_dist = oqparam.maximum_distance
    correl_model = oqparam.correlation_model
    seed = oqparam.random_seed
    imts = map(from_string, sorted(oqparam.intensity_measure_and_types))
    gsim = oqparam.gsim()
    trunc_level = getattr(oqparam, 'truncation_level', None)
    n_gmfs = getattr(oqparam, 'number_of_ground_motion_fields', 1)
    rupture = get_rupture(oqparam)
    res = ground_motion_fields(
        rupture, sitecol, imts, gsim,
        trunc_level, realizations or n_gmfs, correl_model,
        filters.rupture_site_distance_filter(max_dist), seed)
    return {str(imt): matrix for imt, matrix in res.iteritems()}


def make_epsilons(asset_count, num_samples, seed, correlation):
    pass


def compute_risk(oqparam, assets_by_site, seeds_by_site, risk_models, rupture,
                 epsilons):
    trunc_level = getattr(oqparam, 'truncation_level', None)
    sites = []
    assets_by_taxonomy = collections.defaultdict(list)
    for site, assets in assets_by_site:
        sites.append(site)
        for asset in assets:
            assets_by_taxonomy[asset.taxonomy].append(asset)

    sitecol = SiteCollection(sites)
    imts = sorted(map(from_string, oqparam.intensity_measure_types_and_levels))
    gsim = oqparam.gsim()
    gmf = GmfComputer(rupture, sitecol, imts, [gsim], trunc_level)
    gmvs_by_imt = [gmf.compute(seed) for seed in seeds_by_site]
    for taxonomy in assets_by_taxonomy:
        for imt in imts:
            gmvs = map(operator.itemgetter(imt), gmvs_by_imt)
            inp = RiskInput(
                str(imt), taxonomy, assets_by_taxonomy[taxonomy], gmvs)
            outs_by_loss_type = risk_models[imt, taxonomy].compute_outputs(
                inp, monitor)

    n = oqparam.number_of_ground_motion_fields
