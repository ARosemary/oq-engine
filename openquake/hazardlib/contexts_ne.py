# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4
#
# Copyright (C) 2018-2019 GEM Foundation
#
# OpenQuake is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# OpenQuake is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with OpenQuake.  If not, see <http://www.gnu.org/licenses/>.

import sys
import numpy

from openquake.hazardlib import polynomial_chaos as pchaos
from openquake.hazardlib.contexts import ContextMaker, FarAwayRupture, RupData
from openquake.hazardlib.probability_map import ProbabilityMap


class ContextMakerNonErgodic(ContextMaker):
    """
    A class to manage the creation of contexts for distances, sites, rupture.

    :param trt:
    :param gsims:
        A list of instances of
        :class:`openquake.hazardlib.gsim.base.GroundShakingIntensityModel`
    :param param:
        ?
    :param monitor:
    """

    def get_pmap_by_src(self, src_sites, src_mutex=False, rup_mutex=False):
        """
        :param src_sites: an iterator of pairs (source, sites)
        :param src_mutex: True if the sources are mutually exclusive
        :param rup_mutex: True if the ruptures are mutually exclusive
        :return: dictionaries pmap, rdata, calc_times
        """
        it = iter(src_sites)
        while True:
            try:
                src, s_sites = next(it)
                poemap, pcecff = self.get_pmap(src, s_sites, not rup_mutex)
            except StopIteration:
                break
            except Exception as err:
                etype, err, tb = sys.exc_info()
                msg = '%s (source id=%s)' % (str(err), src.source_id)
                raise etype(msg).with_traceback(tb)
        return poemap, pcecff

    def get_pmap(self, src, s_sites, rup_indep=True):
        """
        Given an earthquake source and a collection of sites
        :param src: a hazardlib source
        :param s_sites: the sites affected by it
        :returns: the probability map generated by the source
        """
        imts = self.imts
        sitecol = s_sites.complete
        N, M = len(sitecol), len(imts)
        fewsites = N <= self.max_sites_disagg
        rupdata = RupData(self)
        nrups, nsites = 0, 0
        L, G = len(self.imtls.array), len(self.gsims)
        poemap = ProbabilityMap(L, G)
        # This is the array where we store the polynomial coefficients for the
        # current source. The shape of this array is:
        # num_sites, num_gsim, num_pce_coeff
        pcecff = numpy.zeros((N, L, G, 7))
        for rup, sites in self._gen_rup_sites(src, s_sites):
            try:
                with self.ctx_mon:
                    sctx, dctx = self.make_contexts(sites, rup)
            except FarAwayRupture:
                continue
            with self.gmf_mon:
                mean_std = numpy.zeros((G, 3, len(sctx), M))
                for i, gsim in enumerate(self.gsims):
                    dctx_ = dctx.roundup(gsim.minimum_distance)
                    # This method returns a numpy array of size
                    # 3 x num_sites x num_imts.
                    mean_std[i] = gsim.get_mean_std(sctx, rup, dctx_, imts)
            with self.poe_mon:
                for sid, pne, pce in self._make_pnes(rup, sctx.sids, mean_std):
                    # Returns a probability curve for the given site
                    pcurve = poemap.setdefault(sid, rup_indep)
                    if rup_indep:
                        pcurve.array *= pne
                    else:
                        pcurve.array += (1.-pne) * rup.weight
                    # TODO
                    pcecff[sid, :, :, :] = pcecff[sid, :, :, :] + (pce)
            nrups += 1
            nsites += len(sctx)
            if fewsites:  # store rupdata
                rupdata.add(rup, src.id, sctx, dctx)
        poemap.nrups = nrups
        poemap.nsites = nsites
        poemap.data = rupdata.data
        return poemap, pcecff

    # NB: it is important for this to be fast since it is inside an inner loop
    def _make_pnes(self, rupture, sids, mean_std):
        """
        Given a rupture, this method computes the probability of non-exeedence
        of all the requested intensity measure types for all the defined
        GSIMs.

        :param rupture:
            An instance of :class:`openquake.hazardlib.source.rupture.ParametricProbabilisticRupture`
        :param sids:
            An array with the IDs of the sites within the integration distance
            from the considered rupture
        :param mean_std:
            A numpy array of size: num_gsims x 2(or 3) x num_sites x num_imts
        :returns:
            An iterable providing a tuple of (site_id, pne, pce) where pne is a
            :class:`numpy.ndarray` instance of size num_sites x num_imtls x
            num_gsims. If the gsim supports epistemiC uncertainty also returns
            the PCE coefficients. pce has shape num_sites x num_imtls x
            num_gsims
        """
        imtls = self.imtls
        nsites = len(sids)
        pne_array = numpy.zeros((nsites, len(imtls.array), len(self.gsims)))
        pce_array = numpy.full((nsites, len(imtls.array), len(self.gsims), 7),
                               None)
        for i, gsim in enumerate(self.gsims):
            for m, imt in enumerate(imtls):
                # This returns a slice
                slc = imtls(imt)
                if hasattr(gsim, 'weight') and gsim.weight[imt] == 0:
                    # set by the engine when parsing the gsim logictree;
                    # when 0 ignore the gsim: see _build_trts_branches
                    pno = numpy.ones((nsites, slc.stop - slc.start))
                else:
                    poes = gsim.get_poes(
                        mean_std[i, 0:2, :, m], imtls[imt], self.trunclevel)
                    # Computes the probability of non-exceedance for a given
                    # rupture, GSIM and imt. The output has shape:
                    # num_sites x num_imls
                    pno = rupture.get_probability_no_exceedance(poes)
                    pce = numpy.zeros((nsites, slc.stop - slc.start, 7))
                    # Checking that mean_std contains the ergodic sigma
                    assert mean_std.shape[1] == 3
                    x = mean_std[i, 0:2, :, m]
                    mea_std = numpy.empty_like(x)
                    # This is mean log(gm)
                    mea_std[0, :] = mean_std[i, 0, :, m]
                    # Adjusted total sigma
                    mea_std[1, :] = (mean_std[i, 1, :, m]**2 +
                                     mean_std[i, 2, :, m]**2)**0.5
                    # Computing PCE coefficient degree 0
                    poes_comb = gsim.get_poes(mea_std, imtls[imt],
                                              truncation_level=None)
                    # Computing polynomial chaos coefficients
                    pce[:, :, 1:] = pchaos.get_coeff(mean_std[i, 0, :, m],
                                                     mean_std[i, 1, :, m],
                                                     mean_std[i, 2, :, m],
                                                     imtls[imt])
                    pce[:, :, 0] = poes_comb
                # Updating output
                pne_array[:, slc, i] = pno
                pce_array[:, slc, i, :] = pce * rupture.occurrence_rate
        return zip(sids, pne_array, pce_array)
