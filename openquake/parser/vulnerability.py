# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4
"""
Codec for processing vulnerability curves
from XML files.

A DOM version of the vulnerability model parser,
that takes into account the really small size of this input file.
"""

from lxml import etree

from openquake import kvs
from openquake import shapes
from openquake.xml import NRML
from openquake import producer


class VulnerabilityModelFile(producer.FileProducer):
    """This class parsers a vulnerability model NRML file.
    
    The class is implemented as a generator. For each vulnerability
    function in the parsed instance document it yields a dictionary
    with all the data defined for that function.
    """

    def __init__(self, path):
        producer.FileProducer.__init__(self, path)
        self.vuln_model = etree.parse(self.path).getroot()

    def filter(self, region_constraint=None, attribute_constraint=None):
        """Filtering is not implemented for the vulnerability model."""

        raise NotImplementedError(
                "Filtering is not supported on the vulnerability model")

    def _parse_common_attributes(self):
        """Parse and return the common attributes for all the
        vulnerability functions defined in this NRML file."""

        imls = self.vuln_model.find(".//%sIML" % NRML)

        vulnerability_set = self.vuln_model.find(
                ".//%sdiscreteVulnerabilitySet" % NRML)

        vuln_function = {"IMT": imls.attrib["IMT"]}

        vuln_function["intensityMeasureLevels"] = \
                [float(x) for x in imls.text.strip().split()]

        vuln_function["vulnerabilitySetID"] = \
                vulnerability_set.attrib["vulnerabilitySetID"]

        vuln_function["assetCategory"] = \
                vulnerability_set.attrib["assetCategory"]

        vuln_function["lossCategory"] = \
                vulnerability_set.attrib["lossCategory"]
        
        return vuln_function

    def _parse(self):
        """Parse the vulnerability model."""

        vuln_function = self._parse_common_attributes()

        for raw_vuln_function in self.vuln_model.findall(
                ".//%sdiscreteVulnerability" % NRML):
                 
            loss_ratios = [float(x) for x in
                    raw_vuln_function.find(
                    "%slossRatio" % NRML).text.strip().split()]

            coefficients_variation = [float(x) for x in
                    raw_vuln_function.find(
                    "%scoefficientsVariation" % NRML).text.strip().split()]

            vuln_function["ID"] = \
                    raw_vuln_function.attrib["vulnerabilityFunctionID"]

            vuln_function["probabilisticDistribution"] = \
                    raw_vuln_function.attrib["probabilisticDistribution"]

            vuln_function["lossRatios"] = loss_ratios
            vuln_function["coefficientsVariation"] = coefficients_variation

            yield dict(vuln_function)


# TODO (ac): These two functions should be probably moved elsewhere
def load_vulnerability_model(job_id, path):
    """Load and store the vulnerability model defined in the
    given NRML file in the underlying kvs system."""

    vulnerability_model = {}
    parser = VulnerabilityModelFile(path)

    for vulnerability_curve in parser:
        curve = []
        
        data = zip(vulnerability_curve["lossRatios"],
                vulnerability_curve["coefficientsVariation"])

        for idx, iml in enumerate(
                vulnerability_curve["intensityMeasureLevels"]):

            curve.append((iml, data[idx]))

        vulnerability_model[vulnerability_curve["ID"]] = \
                shapes.Curve(curve).to_json()

    kvs.set_value_json_encoded(kvs.tokens.vuln_key(job_id), 
            vulnerability_model)


def load_vuln_model_from_kvs(job_id):
    """Load the vulnerability model from kvs for the given job."""

    vulnerability_model = kvs.get_value_json_decoded(
            kvs.tokens.vuln_key(job_id))

    vulnerability_curves = {}

    if vulnerability_model is not None:
        for k, v in vulnerability_model.items():
            vulnerability_curves[k] = shapes.Curve.from_json(v)

    return vulnerability_curves
