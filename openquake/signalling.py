# -*- coding: utf-8 -*-

# Copyright (c) 2010-2011, GEM Foundation.
#
# OpenQuake is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License version 3
# only, as published by the Free Software Foundation.
#
# OpenQuake is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License version 3 for more details
# (a copy is included in the LICENSE file that accompanied this code).
#
# You should have received a copy of the GNU Lesser General Public License
# version 3 along with OpenQuake.  If not, see
# <http://www.gnu.org/licenses/lgpl-3.0.txt> for a copy of the LGPLv3 License.

"""
Classes dealing with amqp signalling between jobbers, workers and supervisors.
"""
import threading
import socket

import kombu
import kombu.entity
import kombu.messaging

from openquake.utils import config


class AMQPMessageConsumer(threading.Thread):
    """
    A baseclass to consume logging messages generated by an OpenQuake job.

    Typical use::

        class MyConsumer(AMQPMessageConsumer):
            def message_callback(self, msg):
                # do something usefull
                pass

        MyConsumer('routing.key.#').start()
    """
    def __init__(self, routing_key, timeout=None, daemon=True):
        super(AMQPMessageConsumer, self).__init__()
        self.setDaemon(daemon)

        if timeout is not None:
            assert type(self).timeout_callback \
                   is not AMQPMessageConsumer.timeout_callback, \
                   "please override timeout_callback() method " \
                   "if you want to handle timeouts"
        self.timeout = timeout
        self.routing_key = routing_key
        self._ready = threading.Event()
        self._ready.clear()
        self.channel = self.connection = None
        self._stopped = False

    def run(self):
        """
        Thread's main function of execution.
        """
        cfg = config.get_section("amqp")

        self.connection = kombu.BrokerConnection(hostname=cfg['host'],
                                                 userid=cfg['user'],
                                                 password=cfg['password'],
                                                 virtual_host=cfg['vhost'])
        try:
            self.channel = self.connection.channel()
            self.exchange = kombu.entity.Exchange(cfg['exchange'],
                                                  type='topic',
                                                  channel=self.channel)
            self.exchange.declare()
            self.queue = kombu.entity.Queue(exchange=self.exchange,
                                            channel=self.channel,
                                            routing_key=self.routing_key,
                                            exclusive=True)
            self.queue.queue_declare()
            self.queue.queue_bind()
            consumer = kombu.messaging.Consumer(self.channel, self.queue)
            consumer.register_callback(self._message_callback)
            consumer.consume()

            self._ready.set()

            while not self._stopped:
                try:
                    self.connection.drain_events(timeout=self.timeout)
                except socket.timeout:
                    self._timeout_callback()
        finally:
            if self.channel:
                self.channel.close()
            self.connection.close()
            self._ready.set()

    def start(self):
        """
        Start thread execution.

        Doesn't return until connection, channel, exchange, queue, binding and
        consumer are ready.
        """
        super(AMQPMessageConsumer, self).start()
        self._ready.wait()

    def stop(self):
        """
        Stop thread execution on the next loop iteration in :meth:`run`.
        """
        self._stopped = True

    def _message_callback(self, body, msg):
        payload = msg.decode()
        try:
            self.message_callback(payload, msg)
        except StopIteration:
            msg.ack()
            self.stop()
        else:
            msg.ack()

    def _timeout_callback(self):
        try:
            self.timeout_callback()
        except StopIteration:
            self.stop()

    def message_callback(self, payload, msg):
        """
        Called by :meth:`run` when a message is received.

        Can raise StopIteration to stop the loop inside :meth:`run`
        and terminate thread.
        """
        raise NotImplementedError()

    def timeout_callback(self):
        """
        Called by :meth:`run` each time the timeout expires.

        You need to implement this only if you specify a timeout when creating
        an instance of AMQPMessageConsumer.

        Can raise StopIteration to stop the loop inside :meth:`run`
        and terminate thread.
        """
        pass
