# -*- coding: utf-8 -*-

# Copyright (c) 2010-2011, GEM Foundation.
#
# OpenQuake is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License version 3
# only, as published by the Free Software Foundation.
#
# OpenQuake is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License version 3 for more details
# (a copy is included in the LICENSE file that accompanied this code).
#
# You should have received a copy of the GNU Lesser General Public License
# version 3 along with OpenQuake.  If not, see
# <http://www.gnu.org/licenses/lgpl-3.0.txt> for a copy of the LGPLv3 License.

"""
Classes dealing with amqp signalling between jobbers, workers and supervisors.
"""
import threading
import socket

import kombu

from openquake.utils import config


class AMQPMessageConsumer(threading.Thread):
    """
    A baseclass to consume logging messages generated by an OpenQuake job.

    Typical use::

        class MyConsumer(AMQPMessageConsumer):
            def message_callback(self, msg):
                # do something usefull
                pass

        MyConsumer().start()
    """
    # TODO: unittest
    def __init__(self, routing_key, timeout=None, daemon=True):
        super(AMQPMessageConsumer, self).__init__(daemon=daemon)

        if timeout is not None:
            assert type(self).timeout_callback \
                   is not AMQPMessageConsumer.timeout_callback, \
                   "please override timeout_callback() method " \
                   "if you want to handle timeouts"
        self.timeout = timeout
        cfg = config.get_section("amqp")

        self.connection = kombu.BrokerConnection(hostname=cfg['host'],
                                                 userid=cfg['user'],
                                                 password=cfg['password'],
                                                 virtual_host=cfg['vhost'])
        self.channel = self.connection.channel()
        self.exchange = kombu.entity.Exchange(cfg['exchange'], type='topic',
                                              channel=self.channel)
        self.queue = kombu.entity.Queue(exchange=self.exchange,
                                        channel=self.channel,
                                        routing_key=routing_key)
        self.queue.declare()
        self.queue.consume(callback=self._message_callback)
        self._stopped = False

    def run(self):
        """
        Thread's main function of execution.
        """
        try:
            while not self._stopped:
                try:
                    self.connection.drain_events(timeout=self.timeout)
                except socket.timeout:
                    self._timeout_callback()
        finally:
            self.connection.close()

    def stop(self):
        """
        Stop thread execution on the next loop iteration in :meth:`run`.
        """
        self._stopped = True

    def _message_callback(self, msg):
        try:
            self.message_callback(msg)
        except StopIteration:
            self.channel.basic_ack(msg.delivery_tag)
            self.stop()
        else:
            self.channel.basic_ack(msg.delivery_tag)

    def _timeout_callback(self):
        try:
            self.timeout_callback()
        except StopIteration:
            self.stop()

    def message_callback(self, msg):
        """
        Called by :meth:`run` when a message is received.

        Can raise StopIteration to stop the loop inside :meth:`run`
        and terminate thread.
        """
        raise NotImplementedError()

    def timeout_callback(self):
        """
        Called by :meth:`run` each time the timeout expires.

        You need to implement this only if you specify a timeout when creating
        an instance of AMQPMessageConsumer.

        Can raise StopIteration to stop the loop inside :meth:`run`
        and terminate thread.
        """
        pass
