import collections
import numpy

from django import db

from openquake.engine.calculators.hazard.event_based.core \
    import RuptureData, EventBasedHazardCalculator as EBHC

from openquake.engine.db import models
from openquake.engine.utils import tasks
from openquake.engine.performance import (
    EnginePerformanceMonitor, LightMonitor)

from openquake.hazardlib.imt import from_string
from openquake.commonlib.general import split_in_blocks
from openquake.commonlib.logictree import SourceModelLogicTree, GSIM

from openquake.risklib import scientific

from openquake.engine import logs

from openquake.engine.calculators.risk.event_based import core
from openquake.engine.calculators.risk import writers


class AssetSiteAssociationError(Exception):
    pass


@tasks.oqtask
def event_based_fr(job_id, rupture_data, rc, risk_models, getter_builders,
                   outputdict, params):
    """
    :param int job_id:
        ID of the currently running job
    :param sids:
        numpy array of site IDs
    :param rupture_data:
        a list with the rupture data generated by the parent task
    :param int task_no:
        the number of the task that generated the rupture_data
    """
    hc = rc.hazard_calculation
    correl_model = hc.get_correl_model()
    truncation_level = hc.truncation_level
    imts = map(from_string, sorted(hc.intensity_measure_types))

    # NB: by construction rupture_data is a non-empty list with
    # ruptures of homogeneous trt_model
    trt_model = rupture_data[0].rupture.trt_model

    elt = {}  # event loss table
    rlz2gsim = {
        art.rlz: GSIM[art.gsim]()
        for art in models.AssocLtRlzTrtModel.objects.filter(
            trt_model=trt_model)}

    getdata_mon = EnginePerformanceMonitor(
        'getting hazard', job_id, event_based_fr)
    gmf_mon = getdata_mon.copy('building gmf')
    getters_mon = getdata_mon.copy('building getters')
    for builder in getter_builders.itervalues():
        builder.init_epsilons(rc.asset_correlation)

    for rdata in rupture_data:
        with gmf_mon:
            for rlz, gsim in rlz2gsim.iteritems():
                rlz.gmv_dict = dict((str(imt), collections.defaultdict(dict))
                                    for imt in imts)
                for gsim_name, imt, site_id, rupid, gmv in rdata.calc_gmf(
                        imts, [gsim], truncation_level, correl_model):
                    rlz.gmv_dict[str(imt)][site_id][rupid] = gmv

        with getters_mon:
            for taxonomy, builder in getter_builders.iteritems():
                getters = [
                    builder.make_getter(
                        rlz, rdata.rupid_seed_pairs, rlz.gmv_dict)
                    for rlz in rlz2gsim]

        with db.transaction.commit_on_success(using='job_init'):
            elt.update(
                core.do_event_based(
                    risk_models[taxonomy], getters, outputdict, params,
                    getdata_mon))

    #getdata_mon.flush()
    #gmf_mon.flush()
    #getters_mon.flush()
    return elt


class GetterBuilder(object):
    def __init__(self, rc, taxonomy):
        self.rc = rc
        self.taxonomy = taxonomy
        cursor = models.getcursor('job_init')
        query = '''\
    SELECT exp.id AS asset_id, hsite.id AS site_id
    FROM riski.exposure_data AS exp
    JOIN hzrdi.hazard_site AS hsite
    ON exp.site::TEXT=hsite.location::TEXT
    WHERE hsite.hazard_calculation_id = %s
    AND exposure_model_id = %s AND taxonomy=%s
    AND ST_COVERS(ST_GeographyFromText(%s), exp.site)'''
        args = (rc.hazard_calculation.id, rc.exposure_model.id, taxonomy,
                rc.region_constraint.wkt)
        # print cursor.mogrify(query, args) useful when debugging
        cursor.execute(query, args)
        assets_sites = cursor.fetchall()
        if not assets_sites:
            raise AssetSiteAssociationError(
                'Could not associated any asset of taxonomy %s' % taxonomy)
        self.asset_ids, self.site_ids = zip(*assets_sites)
        self.assets = models.ExposureData.objects.get_asset_chunk(
            rc, taxonomy, asset_ids=self.asset_ids)

    def init_epsilons(self, asset_correlation):
        self.ep = scientific.EpsilonProvider(
            len(self.assets), asset_correlation)

    def make_getter(self, gmf, rupid_seed_pairs, gmv_dict):
        return GmfGetter(gmf, self.ep, rupid_seed_pairs, self.site_ids,
                         self.assets, gmv_dict)


class EventBasedFRRiskCalculator(core.EventBasedRiskCalculator):

    @EnginePerformanceMonitor.monitor
    def execute(self):
        """
        Method responsible for the distribution strategy. It divides
        the considered exposure into chunks of homogeneous assets
        (i.e. having the same taxonomy).
        """
        # create a Gmf output for each realization
        self.hcalc = EBHC(self.hc.oqjob)
        self.hcalc.source_model_lt = SourceModelLogicTree.from_hc(self.hc)
        self.hcalc.initialize_realizations()
        self.compute_risk()

    @EnginePerformanceMonitor.monitor
    def compute_risk(self):
        """
        Generate the GMFs and optionally the hazard curves too, then
        compute the risk.
        """
        otm = tasks.OqTaskManager(event_based_fr, logs.LOG.progress)
        rupture_data = []
        for rupture in models.ProbabilisticRupture.objects.filter(
                trt_model__lt_model__hazard_calculation=self.hc
                ).order_by('trt_model'):
            rdata = RuptureData(
                self.hc.site_collection, rupture,
                [(r.id, r.seed) for r in rupture.sesrupture_set.all()])
            rupture_data.append(rdata)

        getter_builders = {}
        with self.monitor('associating assets<->sites'):
            for taxonomy in self.risk_models:
                logs.LOG.info('associating assets<->sites for taxonomy %s',
                              taxonomy)
                try:
                    with db.transaction.commit_on_success(using='job_init'):
                        getter_builders[taxonomy] = GetterBuilder(
                            self.rc, taxonomy)
                except AssetSiteAssociationError as e:
                    logs.LOG.warn(str(e))
                    continue
        outputdict = writers.combine_builders(
            [ob(self) for ob in self.output_builders])
        with self.monitor('sending ruptures'):
            for rblock in split_in_blocks(
                    rupture_data, self.concurrent_tasks,
                    RuptureData.get_weight, RuptureData.get_trt):
                otm.submit(self.job.id, rblock, self.rc, self.risk_models,
                           getter_builders, outputdict,
                           self.calculator_parameters)
        self.acc = otm.aggregate_results(self.agg_result, {})

    def post_processing(self):
        pass


class GmfGetter(object):
    """
    Hazard getter for computing ground motion values and epsilons from ruptures
    """
    def __init__(self, lt_rlz, epsilon_provider, rupid_seed_pairs,
                 site_ids, assets, gmv_dict):
        self.rlz = lt_rlz
        self.epsilon_provider = epsilon_provider
        self.rupture_ids, self.seeds = zip(*rupid_seed_pairs)
        self.site_ids = site_ids
        self.assets = assets
        self.gmv_dict = gmv_dict
        self.hid = lt_rlz.lt_model.ses_collection.output.id
        self.weight = lt_rlz.weight

    def get_epsilons(self):
        """
        Build the needed epsilon matrix from the given assets and seeds,
        by using the underlying epsilon provider.
        """
        return self.epsilon_provider.sample_many(self.seeds)

    def get_data(self, imt):
        """
        Extracts the GMFs for the given `imt` from the hazard output.

        :param str imt: Intensity Measure Type
        :returns: a list of N arrays with R elements each.
        """
        gmv_dict = self.gmv_dict[imt]
        all_gmvs = []
        for site_id in self.site_ids:
            gmv = gmv_dict.get(site_id, {})
            if not gmv:
                logs.LOG.info('No data for site_id=%d, imt=%s', site_id, imt)
            array = numpy.array([gmv.get(r, 0.) for r in self.rupture_ids])
            all_gmvs.append(array)
        return all_gmvs
