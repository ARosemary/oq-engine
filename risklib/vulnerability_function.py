# coding=utf-8
# Copyright (c) 2010-2012, GEM Foundation.
#
# OpenQuake is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# OpenQuake is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with OpenQuake.  If not, see <http://www.gnu.org/licenses/>.

import json
import numpy

from itertools import izip
from scipy.interpolate import interp1d
from numpy import allclose

from risklib.range import range_clip

class VulnerabilityFunction(object):
    """
    This class represents a vulnerability fuction.

    A vulnerability function has IMLs (Intensity Measure Levels) as
    X values and MLRs, CVs (Mean Loss Ratio and Coefficent of Variation)
    as Y values.
    """

    def __init__(self, imls, loss_ratios, covs, distribution):
        """
        :param imls: Intensity Measure Levels for the vulnerability function.
            All values must be >= 0.0.
        :type imls: list of floats; values must be arranged in ascending order
            with no duplicates
        :param loss_ratios: Loss ratio values, where 0.0 <= value <= 1.0.
        :type loss_ratios: list of floats, equal in length to imls
        :param covs: Coefficients of Variation. All values must be >= 0.0.
        :type covs: list of floats, equal in length to imls
        :param distribution: The probabilistic distribution related to this
            function.
        :type distribution: string
        """
        self._imls = imls
        self._loss_ratios = loss_ratios
        self._covs = covs
        self.distribution = distribution

        # Check for proper IML ordering:
        assert self._imls == sorted(set(self._imls)),\
        "IML values must be in ascending order with no duplicates."

        # Check for proper IML values (> 0.0).
        assert all(x >= 0.0 for x in self._imls),\
        "IML values must be >= 0.0."

        # Check CoV and loss ratio list lengths:
        assert len(self._covs) == len(self._imls),\
        "CoV list should be the same length as the IML list."
        assert len(self._loss_ratios) == len(self._imls),\
        "Loss ratio list should be the same length as the IML list."

        # Check for proper CoV values (>= 0.0):
        assert all(x >= 0.0 for x in self._covs),\
        "CoV values must be >= 0.0."

        # Check for proper loss ratio values (0.0 <= value <= 1.0):
        assert all(x >= 0.0 and x <= 1.0 for x in self._loss_ratios),\
        "Loss ratio values must be in the interval [0.0, 1.0]."

    def __eq__(self, other):
        """
        Compares IML, loss ratio, and CoV values to determine equality.
        """
        if not isinstance(other, VulnerabilityFunction):
            return False
        return allclose(self.imls, other.imls)\
               and allclose(self.loss_ratios, other.loss_ratios)\
               and allclose(self.covs, other.covs) and\
               self.distribution == other.distribution


    @property
    def imls(self):
        """
        IML values as a numpy.array.
        """
        return numpy.array(self._imls)

    @property
    def loss_ratios(self):
        """
        Loss ratios as a numpy.array.
        """
        return numpy.array(self._loss_ratios)

    @property
    def covs(self):
        """
        Coeffecicients of Variation as a numpy.array.
        """
        return numpy.array(self._covs)

    @property
    def is_beta(self):
        return self.distribution == "BT"

    @property
    def is_lognormal(self):
        return self.distribution == "LN"

    @property
    def is_empty(self):
        """
        True if there are no IML values in the function.
        """
        return len(self.imls) == 0

    @property
    def stddevs(self):
        """
            Convenience method: returns a list of calculated
            Standard Deviations
        """
        return [cov * loss_ratio for cov, loss_ratio in izip(self.covs,
            self.loss_ratios)]

    def loss_ratio_for(self, iml):
        """
        Given 1 or more IML values, interpolate the corresponding loss ratio
        value(s) on the curve.

        Input IML value(s) is/are clipped to IML range defined for this
        vulnerability function.

        :param iml: IML value
        :type iml: float (single value), list of floats, or
            :py:class:`numpy.ndarray` of floats

        :returns: :py:class:`numpy.ndarray` containing a number of interpolated
            values equal to the size of the input (1 or many)
        """
        iml = range_clip(iml, self.imls)

        return interp1d(self.imls, self.loss_ratios)(iml)

    def cov_for(self, iml):
        """
        Given 1 or more IML values, interpolate the corresponding Coefficient
        of Variation value(s) on the curve.

        Input IML value(s) is/are clipped to IML range defined for this
        vulnerability function.

        :param iml: IML value
        :type iml: float (single value), list of floats, or
            :py:class:`numpy.ndarray` of floats

        :returns: :py:class:`numpy.ndarray` containing a number of interpolated
            values equal to the size of the input (1 or many)
        """
        iml = range_clip(iml, self.imls)

        return interp1d(self.imls, self.covs)(iml)

    def __iter__(self):
        """Iterate on the values of this function, returning triples
        in the form of (iml, mean loss ratio, cov)."""
        return izip(self.imls, self.loss_ratios, self.covs)

    def to_json(self):
        """
        Serialize this curve in JSON format.
        Given the following sample data::
            imls = [0.005, 0.007]
            loss_ratios = [0.1, 0.3]
            covs = [0.2, 0.4]
            distribution = 'BT'

        the output will be a JSON string structured like so::
            ('BT', {'0.005': [0.1, 0.2],
             '0.007': [0.3, 0.4]})
        """
        as_dict = {}

        for iml, loss_ratio, cov in izip(self.imls, self.loss_ratios,
            self.covs):
            as_dict[str(iml)] = [loss_ratio, cov]

        return json.JSONEncoder().encode((self.distribution, as_dict))

    @classmethod
    def from_tuple(cls, vuln_func):
        """
        Construct a VulnerabiltyFunction from a tuple.

        The first element of the tuple is the probabilistic
        distribution related to this function.

        The second element is a dictionary of values.

        The dictionary keys can be unordered and of
        whatever type can be converted to float with float().
        :param vuln_func_dict: A dictionary of [loss ratio, CoV] pairs, keyed
            by IMLs.
            The IML keys can be numbers represented as either a string or
            float.
            Example::
                {'0.005': [0.1, 0.2],
                 '0.007': [0.3, 0.4],
                 0.0098: [0.5, 0.6]}

        :type vuln_func: tuple

        :returns: :py:class:`openquake.shapes.VulnerabilityFunction` instance
        """

        distribution = vuln_func[0]
        values = vuln_func[1]

        # flatten out the dict and convert keys to floats:
        data = [(float(iml), lr_cov) for iml, lr_cov in values.items()]
        # sort the data (by iml) in ascending order:
        data = sorted(data, key=lambda x: x[0])

        imls = []
        loss_ratios = []
        covs = []

        for iml, (lr, cov) in data:
            imls.append(iml)
            loss_ratios.append(lr)
            covs.append(cov)

        return cls(imls, loss_ratios, covs, distribution)

    @classmethod
    def from_json(cls, json_str):
        """Construct a curve from a serialized version in
        json format.

        :returns: :py:class:`openquake.shapes.VulnerabilityFunction` instance
        """
        as_list = json.JSONDecoder().decode(json_str)
        return cls.from_tuple(as_list)


EMPTY_VULN_FUNCTION = VulnerabilityFunction([], [], [], "LN")
