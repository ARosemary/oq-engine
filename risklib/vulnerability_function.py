# coding=utf-8
# Copyright (c) 2010-2012, GEM Foundation.
#
# OpenQuake is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# OpenQuake is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with OpenQuake.  If not, see <http://www.gnu.org/licenses/>.

import json
import numpy

from itertools import izip
from scipy.interpolate import interp1d
from numpy import allclose

from risklib.range import range_clip


class VulnerabilityFunction(object):
    """
    This class represents a vulnerability fuction.

    A vulnerability function has IMLs (Intensity Measure Levels) as
    X values and MLRs, CVs (Mean Loss Ratio and Coefficent of Variation)
    as Y values.
    """

    def __init__(self, imls, loss_ratios, covs, distribution):
        """
        :param imls: Intensity Measure Levels for the vulnerability function.
            All values must be >= 0.0.
        :type imls: list of floats; values must be arranged in ascending order
            with no duplicates
        :param loss_ratios: Loss ratio values, where 0.0 <= value <= 1.0.
        :type loss_ratios: list of floats, equal in length to imls
        :param covs: Coefficients of Variation. All values must be >= 0.0.
        :type covs: list of floats, equal in length to imls
        :param distribution: The probabilistic distribution related to this
            function.
        :type distribution: string
        """
        self._imls = imls
        self._loss_ratios = loss_ratios
        self._covs = covs
        self.distribution = distribution

        # Check for proper IML ordering:
        assert self._imls == sorted(set(self._imls))

        # Check for proper IML values (> 0.0).
        assert all(x >= 0.0 for x in self._imls)

        # Check CoV and loss ratio list lengths:
        assert len(self._covs) == len(self._imls)

        assert len(self._loss_ratios) == len(self._imls)

        # Check for proper CoV values (>= 0.0):
        assert all(x >= 0.0 for x in self._covs)

        # Check for proper loss ratio values (0.0 <= value <= 1.0):
        assert all(x >= 0.0 and x <= 1.0 for x in self._loss_ratios)

    def __eq__(self, other):
        """
        Compares IML, loss ratio, and CoV values to determine equality.
        """
        if not isinstance(other, VulnerabilityFunction):
            return False
        return (allclose(self.imls, other.imls)
                and allclose(self.loss_ratios, other.loss_ratios)
                and allclose(self.covs, other.covs) and
                self.distribution == other.distribution)

    @property
    def imls(self):
        """
        IML values as a numpy.array.
        """
        return numpy.array(self._imls)

    @property
    def loss_ratios(self):
        """
        Loss ratios as a numpy.array.
        """
        return numpy.array(self._loss_ratios)

    @property
    def covs(self):
        """
        Coeffecicients of Variation as a numpy.array.
        """
        return numpy.array(self._covs)

    @property
    def is_beta(self):
        """
        True if this vulnerability function is defined with
        a beta distribution.
        """
        return self.distribution == "BT"

    @property
    def is_lognormal(self):
        return self.distribution == "LN"

    @property
    def is_empty(self):
        """
        True if there are no IML values in the function.
        """
        return len(self.imls) == 0

    @property
    def stddevs(self):
        """
            Convenience method: returns a list of calculated
            Standard Deviations
        """
        return [cov * loss_ratio for cov, loss_ratio in izip(self.covs,
            self.loss_ratios)]

    def loss_ratio_for(self, iml):
        """
        Given 1 or more IML values, interpolate the corresponding loss ratio
        value(s) on the curve.

        Input IML value(s) is/are clipped to IML range defined for this
        vulnerability function.

        :param iml: IML value
        :type iml: float (single value), list of floats, or
            :py:class:`numpy.ndarray` of floats

        :returns: :py:class:`numpy.ndarray` containing a number of interpolated
            values equal to the size of the input (1 or many)
        """

        if isinstance(iml, float):
            if iml > self.imls[-1]:
                return self.loss_ratios[-1]
            elif iml < self.imls[0]:
                return 0.
            else:
                return interp1d(self.imls, self.loss_ratios)(iml)

        ret = numpy.zeros(len(iml))

        saturated = numpy.where(iml > self.imls[-1])
        ret[saturated] = numpy.ones(len(saturated)) * self.loss_ratios[-1]

        to_interpolate = numpy.intersect1d(
            numpy.where(iml <= self.imls[-1])[0],
            numpy.where(iml >= self.imls[0])[0],
            assume_unique=True)

        ret[to_interpolate] = interp1d(self.imls, self.loss_ratios)(
            numpy.array(iml)[to_interpolate])

        return ret

    def cov_for(self, iml):
        """
        Given 1 or more IML values, interpolate the corresponding Coefficient
        of Variation value(s) on the curve.

        Input IML value(s) is/are clipped to IML range defined for this
        vulnerability function.

        :param iml: IML value
        :type iml: float (single value), list of floats, or
            :py:class:`numpy.ndarray` of floats

        :returns: :py:class:`numpy.ndarray` containing a number of interpolated
            values equal to the size of the input (1 or many)
        """
        iml = range_clip(iml, self.imls)

        return interp1d(self.imls, self.covs)(iml)

    def __iter__(self):
        """Iterate on the values of this function, returning triples
        in the form of (iml, mean loss ratio, cov)."""
        return izip(self.imls, self.loss_ratios, self.covs)

    def to_json(self):
        """
        Serialize this curve in JSON format.
        Given the following sample data::
            imls = [0.005, 0.007]
            loss_ratios = [0.1, 0.3]
            covs = [0.2, 0.4]
            distribution = 'BT'

        the output will be a JSON string structured like so::
            ('BT', {'0.005': [0.1, 0.2],
             '0.007': [0.3, 0.4]})
        """
        as_dict = {}

        for iml, loss_ratio, cov in izip(self.imls, self.loss_ratios,
            self.covs):
            as_dict[str(iml)] = [loss_ratio, cov]

        return json.JSONEncoder().encode((self.distribution, as_dict))

    @classmethod
    def from_tuple(cls, vuln_func):
        """
        Construct a VulnerabiltyFunction from a tuple.

        The first element of the tuple is the probabilistic
        distribution related to this function.

        The second element is a dictionary of values.

        The dictionary keys can be unordered and of
        whatever type can be converted to float with float().
        :param vuln_func_dict: A dictionary of [loss ratio, CoV] pairs, keyed
            by IMLs.
            The IML keys can be numbers represented as either a string or
            float.
            Example::
                {'0.005': [0.1, 0.2],
                 '0.007': [0.3, 0.4],
                 0.0098: [0.5, 0.6]}

        :type vuln_func: tuple

        :returns: :py:class:`openquake.shapes.VulnerabilityFunction` instance
        """

        distribution = vuln_func[0]
        values = vuln_func[1]

        # flatten out the dict and convert keys to floats:
        data = [(float(iml), lr_cov) for iml, lr_cov in values.items()]
        # sort the data (by iml) in ascending order:
        data = sorted(data, key=lambda x: x[0])

        imls = []
        loss_ratios = []
        covs = []

        for iml, (lr, cov) in data:
            imls.append(iml)
            loss_ratios.append(lr)
            covs.append(cov)

        return cls(imls, loss_ratios, covs, distribution)

    @classmethod
    def from_json(cls, json_str):
        """Construct a curve from a serialized version in
        json format.

        :returns: :py:class:`openquake.shapes.VulnerabilityFunction` instance
        """
        as_list = json.JSONDecoder().decode(json_str)
        return cls.from_tuple(as_list)


EMPTY_VULN_FUNCTION = VulnerabilityFunction([], [], [], "LN")


def _mean_imls(vulnerability_function):
    """
    Compute the mean IMLs (Intensity Measure Level)
    for the given vulnerability function.

    :param vulnerability_function: the vulnerability function where
        the IMLs (Intensity Measure Level) are taken from.
    :type vuln_function:
       :py:class:`risklib.vulnerability_function.VulnerabilityFunction`
    """

    imls = vulnerability_function.imls

    # "special" cases for lowest part and highest part of the curve
    lowest_iml_value = imls[0] - ((imls[1] - imls[0]) / 2)

    # if the calculated lowest_curve_value goes < 0 we have to force the 0
    # IMLs have to be >= 0
    if lowest_iml_value < 0:
        lowest_iml_value = 0

    highest_iml_value = imls[-1] + ((imls[-1] - imls[-2]) / 2)
    between_iml_values = [numpy.mean(x) for x in zip(imls, imls[1:])]

    return [lowest_iml_value] + between_iml_values + [highest_iml_value]
