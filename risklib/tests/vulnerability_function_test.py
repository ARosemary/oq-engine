# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4

# Copyright (c) 2010-2012, GEM Foundation.
#
# OpenQuake is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# OpenQuake is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with OpenQuake.  If not, see <http://www.gnu.org/licenses/>.

import json
import unittest
import numpy

from risklib.vulnerability_function import VulnerabilityFunction


def assert_close(expected, actual):
    return numpy.testing.assert_allclose(
        expected, actual, atol=0.0, rtol=1E-7)


class VulnerabilityFunctionTestCase(unittest.TestCase):
    """
    Test for :py:class:`risklib.vulnerability_function.VulnerabilityFunction`.
    """
    IMLS_GOOD = [0.005, 0.007, 0.0098, 0.0137, 0.0192, 0.0269]
    IMLS_BAD = [-0.1, 0.007, 0.0098, 0.0137, 0.0192, 0.0269]
    IMLS_DUPE = [0.005, 0.005, 0.0098, 0.0137, 0.0192, 0.0269]
    IMLS_BAD_ORDER = [0.005, 0.0098, 0.007, 0.0137, 0.0192, 0.0269]

    LOSS_RATIOS_GOOD = [0.1, 0.3, 0.0, 0.5, 1.0, 0.6]
    LOSS_RATIOS_BAD = [0.1, 0.3, 0.0, 1.1, -0.1, 0.6]
    LOSS_RATIOS_TOO_SHORT = [0.1, 0.3, 0.0, 0.5, 1.0]
    LOSS_RATIOS_TOO_LONG = [0.1, 0.3, 0.0, 0.5, 1.0, 0.6, 0.5]

    COVS_GOOD = [0.3, 0.1, 0.3, 0.0, 0.3, 10]
    COVS_BAD = [-0.1, 0.1, 0.3, 0.0, 0.3, 10]
    COVS_TOO_SHORT = [0.3, 0.1, 0.3, 0.0, 0.3]
    COVS_TOO_LONG = [0.3, 0.1, 0.3, 0.0, 0.3, 10, 11]

    @classmethod
    def setUpClass(cls):
        cls.test_func = VulnerabilityFunction(
            cls.IMLS_GOOD, cls.LOSS_RATIOS_GOOD, cls.COVS_GOOD, "LN")

    def test_vuln_func_constructor_with_good_input(self):
        VulnerabilityFunction(
            self.IMLS_GOOD, self.LOSS_RATIOS_GOOD, self.COVS_GOOD, "LN")

    def test_vuln_func_constructor_raises_on_bad_imls(self):
        # This test attempts to invoke AssertionErrors by passing 3 different
        # sets of bad IMLs to the constructor:
        #     - IML list containing out-of-range value(s)
        #     - IML list containing duplicates
        #     - IML list ordered improperly
        self.assertRaises(
            AssertionError, VulnerabilityFunction,
            self.IMLS_BAD, self.LOSS_RATIOS_GOOD, self.COVS_GOOD, "LN")

        self.assertRaises(
            AssertionError, VulnerabilityFunction,
            self.IMLS_DUPE, self.LOSS_RATIOS_GOOD, self.COVS_GOOD, "LN")

        self.assertRaises(
            AssertionError, VulnerabilityFunction,
            self.IMLS_BAD_ORDER, self.LOSS_RATIOS_GOOD, self.COVS_GOOD, "LN")

    def test_vuln_func_constructor_raises_on_bad_cov(self):
        # This test attempts to invoke AssertionErrors by passing 3 different
        # sets of bad CoV values to the constructor:
        #     - CoV list containing out-range-values
        #     - CoV list which is shorter than the IML list
        #     - CoV list which is longer than the IML list
        self.assertRaises(
            AssertionError, VulnerabilityFunction,
            self.IMLS_GOOD, self.LOSS_RATIOS_GOOD, self.COVS_BAD, "LN")

        self.assertRaises(
            AssertionError, VulnerabilityFunction,
            self.IMLS_GOOD, self.LOSS_RATIOS_GOOD, self.COVS_TOO_SHORT, "LN")

        self.assertRaises(
            AssertionError, VulnerabilityFunction,
            self.IMLS_GOOD, self.LOSS_RATIOS_GOOD, self.COVS_TOO_LONG, "LN")

    def test_vuln_func_constructor_raises_on_bad_loss_ratios(self):
        # This test attempts to invoke AssertionErrors by passing 3 different
        # sets of bad loss ratio values to the constructor:
        #     - loss ratio list containing out-range-values
        #     - loss ratio list which is shorter than the IML list
        #     - loss ratio list which is longer than the IML list
        self.assertRaises(
            AssertionError, VulnerabilityFunction,
            self.IMLS_GOOD, self.LOSS_RATIOS_BAD, self.COVS_GOOD, "LN")

        self.assertRaises(
            AssertionError, VulnerabilityFunction,
            self.IMLS_GOOD, self.LOSS_RATIOS_TOO_SHORT, self.COVS_GOOD, "LN")

        self.assertRaises(
            AssertionError, VulnerabilityFunction,
            self.IMLS_GOOD, self.LOSS_RATIOS_TOO_LONG, self.COVS_GOOD, "LN")

    def test_from_tuple(self):
        data_dict = {
            '0.005': [0.1, 0.2],
            '0.007': [0.3, 0.4],
            0.0098: [0.5, 0.6]}

        vuln_curve = VulnerabilityFunction.from_tuple(("BT", data_dict))

        assert_close([0.005, 0.007, 0.0098], vuln_curve.imls)
        assert_close([0.1, 0.3, 0.5], vuln_curve.loss_ratios)
        assert_close([0.2, 0.4, 0.6], vuln_curve.covs)
        self.assertEqual("BT", vuln_curve.distribution)

    def test_from_json(self):
        vuln_func_json = '["BT", {"0.005": [0.1, 0.2], "0.007": [0.3, 0.4],'\
            ' "0.0098": [0.5, 0.6]}]'

        vuln_curve = VulnerabilityFunction.from_json(vuln_func_json)

        assert_close([0.005, 0.007, 0.0098], vuln_curve.imls)
        assert_close([0.1, 0.3, 0.5], vuln_curve.loss_ratios)
        assert_close([0.2, 0.4, 0.6], vuln_curve.covs)
        self.assertEqual("BT", vuln_curve.distribution)

    def test_to_json(self):
        imls = [0.005, 0.007, 0.0098]
        loss_ratios = [0.1, 0.3, 0.5]
        covs = [0.2, 0.4, 0.6]

        vuln_func = VulnerabilityFunction(imls, loss_ratios, covs, "LN")

        expected_json = '["LN", {"0.005": [0.1, 0.2], "0.007": [0.3, 0.4], '\
            '"0.0098": [0.5, 0.6]}]'

        # The JSON data (which is essentially a dict) may not come out with the
        # data ordered in a predictable way. So, we'll decode the expected and
        # actual values and compare them as dicts.

        json_decoder = json.JSONDecoder()
        self.assertEqual(json_decoder.decode(expected_json),
                         json_decoder.decode(vuln_func.to_json()))

    def test_eq(self):
        # Exercise equality comparison of VulnerabilityFunctions. Two functions
        # created with the same IML, Loss Ratio, and CoV values should be
        # considered equal.
        imls = [0.005, 0.007]
        loss_ratios = [0.0, 1.0]
        covs = [0.05, 0.05]

        func1 = VulnerabilityFunction(imls, loss_ratios, covs, "LN")
        func2 = VulnerabilityFunction(imls, loss_ratios, covs, "LN")

        self.assertEqual(func1, func2)

    def test_loss_ratio_interp_single_value(self):
        # lower boundary:
        self.assertEqual(0.1, self.test_func.loss_ratio_for(0.005))
        # upper boundary:
        self.assertEqual(0.6, self.test_func.loss_ratio_for(0.0269))
        # between the first 2 IMLs:
        self.assertEqual(0.2, self.test_func.loss_ratio_for(0.006))

    def test_loss_ratio_interp_single_value_clipped(self):
        # Test that loss ratio interpolation properly clips out-of-range input
        # values to the IML range defined for the vulnerability function.
        # test low-end clipping:
        self.assertEqual(0.1, self.test_func.loss_ratio_for(0.0049))
        # test high-end clipping:
        self.assertEqual(0.6, self.test_func.loss_ratio_for(0.027))

    def test_loss_ratio_interp_many_values(self):
        expected_lrs = numpy.array([0.1, 0.2, 0.6])
        test_input = [0.005, 0.006, 0.0269]

        assert_close(expected_lrs, self.test_func.loss_ratio_for(test_input))
        # same thing, except the input is a numpy.ndarray type:
        assert_close(
            expected_lrs,
            self.test_func.loss_ratio_for(numpy.array(test_input)))

    def test_loss_ratio_interp_many_values_clipped(self):
        # Given a list of IML values (abscissae), test for proper interpolation
        # of loss ratios (ordinates).
        # This test also ensures that input IML values are 'clipped' to the IML
        # range defined for the vulnerability function.
        expected_lrs = numpy.array([0.1, 0.2, 0.6])
        test_input = [0.0049, 0.006, 0.027]

        assert_close(
            expected_lrs, self.test_func.loss_ratio_for(test_input))
        # same thing, except the input is a numpy.ndarray type:
        assert_close(
            expected_lrs,
            self.test_func.loss_ratio_for(numpy.array(test_input)))

    def test_cov_interp_single_value(self):
        # Test that single CoV values are properly interpolated.
        # lower boundary:
        self.assertEqual(0.3, self.test_func.cov_for(0.005))
        # upper boundary:
        self.assertEqual(10, self.test_func.cov_for(0.0269))
        # between the first 2 IMLs:
        self.assertEqual(0.2, self.test_func.cov_for(0.006))

    def test_cov_interp_single_value_clipped(self):
        # test low-end clipping:
        self.assertEqual(0.3, self.test_func.cov_for(0.0049))
        # test high-end clipping:
        self.assertEqual(10, self.test_func.cov_for(0.027))

    def test_cov_interp_many_values(self):
        expected_covs = numpy.array([0.3, 0.2, 10])
        test_input = [0.005, 0.006, 0.0269]

        self.assertTrue(
            numpy.allclose(expected_covs,
                           self.test_func.cov_for(test_input)))
        # same thing, except the input is a numpy.ndarray type:
        assert_close(
            expected_covs, self.test_func.cov_for(numpy.array(test_input)))

    def test_cov_interp_many_values_clipped(self):
        # Given a list of IML values (abscissae), test for proper interpolation
        # of CoVs.
        # This test also ensures that input IML values are 'clipped' to the IML
        # range defined for the vulnerability function.
        expected_covs = numpy.array([0.3, 0.2, 10])
        test_input = [0.0049, 0.006, 0.027]

        assert_close(expected_covs, self.test_func.cov_for(test_input))
        # same thing, except the input is a numpy.ndarray type:
        assert_close(expected_covs,
                     self.test_func.cov_for(numpy.array(test_input)))

    def test_is_empty(self):
        empty_func = VulnerabilityFunction([], [], [], "LN")

        # Test empty function:
        self.assertFalse(bool(empty_func))

        # Test non-empty function:
        self.assertTrue(bool(self.test_func))

    def test_iter(self):
        expected = zip(self.IMLS_GOOD, self.LOSS_RATIOS_GOOD, self.COVS_GOOD)
        self.assertEqual(expected, list(self.test_func))

    def test_is_beta(self):
        log_normal = VulnerabilityFunction([], [], [], "LN")
        self.assertFalse(log_normal.is_beta)

        beta = VulnerabilityFunction([], [], [], "BT")
        self.assertTrue(beta.is_beta)
