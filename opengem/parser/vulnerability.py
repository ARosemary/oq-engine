# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4

from lxml import etree
from ordereddict import OrderedDict

from opengem import producer
from opengem import shapes
from opengem import state
STATE = state.STATE
    
# do not use namespace for now
RISKML_NS=''


class VulnerabilityModelFile(producer.FileProducer):
    """ This class parses an VulnerabilityModel XML file.
    The contents of such a file is meant to be used as input for the risk 
    engine.The class is implemented as a generator. For each 
    'VulnerabilityFunction', 'IntensityMeasureValues', and 
    'CoefficientVariationValues' 
    element in the parsed instance document.
    
    The attribute dictionary looks like
    {'Asset': 'Population',
     'Loss': 'Fatalities',
     'ID': 'IR',
     'IntensityMeasureType': 'MMI',
     'ProbabilisticDistribution': LN,
     'IntensityMeasureValues': [ 5.00 5.50 6.00 6.50 7.00 7.50 8.00 8.50 9.00 
     9.50 10.00 ],
     'LossRatioValues': [ 0.00 0.00 0.00 0.00 0.00 0.01 0.06 0.18 0.36 0.36 
     0.36 ],
     'CoefficientVariationValues': [ 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 
     0.30 0.30 0.30 ]
    }

    Note: at the time of writing this class the author has no access to the
    XML Schema, so all XML attributes from the example instance documents are
    assumed to be mandatory
    """
    def _parse(self):
        
        for event, element in etree.iterparse(self.file,
                                              events=('start', 'end')):
            if event == 'start' and element.tag == 'VulnerabilityModel':
                self._vulnerability_model_meta(element)
            elif event == 'end' and element.tag == 'VulnerabilityFunction':
                yield self._to_attributes(element)
                    
    def _vulnerability_model_meta(self, vuln_element):

        self._current_vulnerability_model_meta = {}

        for required_attribute in (('Asset', str), 
                                   ('Loss', str)):
            attr_value = vuln_element.get(required_attribute[0])
            if attr_value is not None:
                self._current_vulnerability_model_meta[required_attribute[0]]\
                = required_attribute[1](attr_value)
            else:
                error_str = "element VulnerabilityModel: missing required " \
                    "attribute %s" % required_attribute[0]
                raise ValueError(error_str) 

    def _to_attributes(self, element):

        attributes = {}
        
        for child_el in ('IntensityMeasureValues', 'LossRatioValues',
        'CoefficientVariationValues'):
            child_node = element.xpath(child_el)
        
            try:
                attributes[child_el] = map(float, 
                    child_node[0].text.strip().split())
            except Exception:
                error_str = "invalid or missing %s value" % child_el
                raise ValueError(error_str) 
                
        # consider all attributes of VulnerabilityFunction element as mandatory 
        for required_attribute in (('ID', str), 
                                   ('IntensityMeasureType', str),
                                   ('ProbabilisticDistribution', str)):
            attr_value = element.get(required_attribute[0])
            if attr_value is not None:
                attributes[required_attribute[0]] = \
                    required_attribute[1](attr_value)
            else:
                error_str = "element VulnerabilityFunction: missing required "\
                    "attribute %s" % required_attribute[0]
                raise ValueError(error_str) 

        try:
            attributes.update(self._current_vulnerability_model_meta)
        except Exception:
            error_str = "root element (VulnerabilityModel) is missing"
            raise ValueError(error_str) 
  
        return attributes
    
    def filter(self, attribute_constraint=None):
        for next in iter(self):
            if (attribute_constraint is not None and \
                    attribute_constraint.match(next)):
                yield next


EMPTY_CODE = 'EMPTY'
STATE['vulnerability_curves_raw'] = {}
STATE['vulnerability_curves'] = {}
STATE['vulnerability_curves'][EMPTY_CODE] = shapes.EMPTY_CURVE

def register_vuln_curve(code, curve):
    STATE['vulnerability_curves'][code] = curve

def ingest_vulnerability(path):
    """Reads a file of vulnerability curves and loads them into shared state."""

    for data in VulnerabilityModelFile(path):
        curve_data = OrderedDict()
        pairs = zip(data['LossRatioValues'], data['CoefficientVariationValues'])
        
        for idx, IML in enumerate(data['IntensityMeasureValues']):
            curve_data["%s" % IML] = pairs[idx]
        STATE['vulnerability_curves_raw'][data['ID']] = data    
        register_vuln_curve(data['ID'], shapes.Curve(curve_data))
        